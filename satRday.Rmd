---
title: "R's NSE learn-along"
author: "Edwin Thoen"
date: "7/23/2018"
output: ioslides_presentation
---

## Why do we love R so much for data-analysis?

- R is very interactive, Q&A with your data

## Why do we love R so much for data-analysis?

- R has fantastic functionalities for plotting

## Why do we love R so much for data-analysis?

- R is super rich in statistical models:

## Why do we love R so much for data-analysis?

- We can program in R:

## Why do we love R so much for data-analysis?

- We don't have to use base R:

## What is a DSL?


## We all use NSE:

When you started using R, did you mix up?

```{r, eval=FALSE}
install.packages("padr")
```

and

```{r, eval=FALSE}
library(padr)
```

Or wondered why the `library(padr)` worked. Even when there is no `padr` variable in the environment?

## We all use NSE:

Apparantly, things that ought not to work, are working.

This results is a language full of black magic (also in base):

```{r, eval = FALSE}
library(mtcars)

subset(mtcars, cyl == 6)

ggplot2::ggplot(mtcars, aes(mpg, drat)) +
  geom_point()

data.table::as.data.table(mtcars)[ ,mean(mpg), by = cyl]
```

## Why data analysts love it and cs people don't

R is designed to do data science. (Well, then it was called statistics).

Flexibility to maximize insights.

Enable DSL creation that remove burdens and slow you down.

With flexibility comes ambiguity and responsibility.

DSL's can only work if they intuitively close to what you know and expect.

## For the love of flame wars

<Wes tweet>

## What to expect?

<learn along>

## What to expect?

Going over some key concepts of NSE in base R.

- promise
- quote
- expression
- name
- environment

Have a look at tidy evaluation and how it differes from base R.

## What is standard in the first place?

```{r}
my_val <- 123

my_func <- function(x) {
  x / 42 * 121
}

my_func(71)

my_func(my_val)

my_func(your_val)
```

## What's in a NAME

<Romeo and Juliet>

## What's in a NAME

```{r}
my_val <- 123
```

123 is the **value** that is bound to the **name** `my_val`.

Binding happens in an environment, in this case the global.

## What's in a NAME

```{r}
my_val <- 123
```

123 is the **value** that is bound to the **name** `my_val`.

Binding happens in an environment, in this case the global.

Just call my name, honey, I'll give you the value:

```{r}
my_val
```

## Lexical scoping

<foto iemand met verrekijker>

## Lexical scoping

R starts looking for the value of name in the local environment.

```{r}
x <- "a variable in the global"
a_func <- function() {
  x <- "a variable in the local"
  x
}
a_func()
```

## Lexical scoping

When it can't find it locally, move up to the parent environment.

```{r}
z <- "a variable in the global"
another_func <- function() {
  z
}
another_func()
```

## Lexical scoping

Finally, an error is thrown when the variable can't be found.

```{r, error=TRUE}
nobody_loves_me <- function() {
  y
}
nobody_loves_me()
```

## Wait for it

When evaluating a name we look for the value bound to it. We err when we can't find it. 

We can also ask R to postpone judgement, by storing the request in a name object.

```{r}
quote(my_unknown_var) %>% class()
```

## Wait for it

When evaluating a name we look for the value bound to it. R errs when it can't find the value. 

We can also ask R to postpone judgement, by storing the request in a name object.

```{r}
quote(my_unknown_var) %>% class()
```

This is the act of **quoting**, saving something to be evaluated later.

## Wait for it

Quoted variable names are not evaluated. It doesn't matter if they don't exist.

```{r}
quated_var <- quote(wait_for_it)
quated_var
```

## Wait for it

Quoted variable names are not evaluated. It doesn't matter if they don't exist.

```{r}
quoted_var <- quote(wait_for_it)
quoted_var
```

It will start looking for the value only we ask to evaluate it.

```{r}
eval(quoted_var)
```

```{r}
wait_for_it <- "I finally have a value"
eval(quoted_var)
```

## Not just names

We can quote the following things:

* *name*: the name of an R object

* *call*: calling of a function

* *pairlist*:

* *literal*: evaluates to the value itself

## Expressions

<NWA express yourself>

## Call

Evaluating a function, can be delayed by quoting it.

```{r}
my_little_filter <- function(x, 
                             call) {
  x[eval(call, envir = x), ]
}

my_little_filter(mtcars, quote(cyl == 4)) %>% head(2)
```


## 

<Meme of angry kid: "But I don't want to quote myself">

## Quoting inside the function

You'll never have to quote your function arguments when using a DSL.

```{r, eval = FALSE}
mtcars %>% select(cyl)
as.data.table(mtcars)[, cyl]
ggplot(mtcars, aes(cyl)) + geom_bar()
```

Why does R not from an error? There is no `cyl` in the global...

## Lazy, lazy R

<koala foto>

## Lazy, lazy R

```{r}
koala <- function(x, y) {
  x + 42
}

koala(3)
```

## Obnoxious Python

<kid sitting in the front of the class>

## Obnoxious Python

```{python}
def koala(x, y):
  return(x + 42)

koala(3)
```

Python is strict, you said there were going to be two arguments, if there are not its wrong.

## Quoting inside a function

So, R is this chilled-out kid that doesn't make a fuz until it realy has to.

We can quote inside functions.

```{r}
my_second_little_filter <- function(x, bare_call) {
  call <- quote(bare_call)
  x[eval(call, envir = x), ]
}

my_second_little_filter(mtcars, cyl == 4) %>% head(2)
```

Why isn't this working?

## Quoting inside a function

```{r}
my_correct_second_little_filter <- function(x, bare_call) {
  call <- substitute(bare_call)
  x[eval(call, envir = x), ]
}
```

Instead of `quote`, which quotes the argument name rather than the variable, we use `substitute`.

```{r}
my_correct_second_little_filter(mtcars, cyl == 4) %>% head(2)
```

## That's a promise

Each function argument is stored in a promise:

<illustratie drie blokjes argument: value: expression>

When the argument gets evaluated in the function, R will retrieve the value and R if it can't find it.

`substitute` takes the promise's expression, it doesn't matter if there is no valid value. 

## All together

```{r}
my_correct_second_little_filter <- function(x, bare_call) {
  call <- substitute(bare_call)
  x[eval(call, envir = x), ]
}

my_correct_second_little_filter(mtcars, cyl == 4) %>% head(1)
```


* The call `cyl == 4` on itself is invalid, there is no `cyl` variable in the globla.
* But, R refrains from judgement, stores it in a promise.
* `substitute` retrieves just the expression, which is the quoted call.
* This expression is evaluated within the environment of `x`.
* Here it is completely valid, because there is a `cyl` variable.

## Quoting strings

```{r}
func1 <- function() "Calling function 1"
func2 <- function() "Calling function 2"

func_caller <- function(nr) { 
  eval(parse(text = paste0("func", nr)))()
}

func_caller(1)
func_caller(2)
```

## A useful example

```{r}
get_source_data <- function(nr,
                            rerun = FALSE) {
  file_path <- paste0("data/source_data_", nr, ".Rdata")
  if (file.exists(file_path) && !rerun) {
    load(file_path)
  } else {
    assign(paste0("source_data_", nr), run_query(nr))
    save(list = paste0("source_data_", nr), file = file_path)
  }
  parse(text = paste0("source_data_", nr)) %>% eval()
}
```

